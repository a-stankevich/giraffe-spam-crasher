package main

import (
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

type AutoGenerated struct {
	Messages []struct {
		ID               int    `json:"id"`
		Type             string `json:"type"`
		DateUnixtime     string `json:"date_unixtime"`
		From             string `json:"from"`
		FromID           string `json:"from_id"`
		ReplyToMessageID int    `json:"reply_to_message_id"`
		TextEntities     []struct {
			Type string `json:"type"`
			Text string `json:"text"`
		} `json:"text_entities"`
	} `json:"messages"`
}

type User struct {
	ID           string
	Name         string
	FirstSeen    time.Time
	CountMessage int
	FirstMessage string
}

func main() {
	inputFile := flag.String("input", "", "Input JSON file path")
	outputFile := flag.String("output", "", "Output CSV file path")
	flag.Parse()

	if *inputFile == "" || *outputFile == "" {
		fmt.Println("Please provide both input and output file paths")
		flag.PrintDefaults()
		os.Exit(1)
	}

	data, err := os.ReadFile(*inputFile)
	if err != nil {
		fmt.Printf("Error reading input file: %v\n", err)
		os.Exit(1)
	}

	exported := AutoGenerated{}
	err = json.Unmarshal(data, &exported)
	if err != nil {
		fmt.Printf("Error unmarshaling JSON: %v\n", err)
		os.Exit(1)
	}

	users := make(map[string]*User)
	newUsersCount := 0

	for i, message := range exported.Messages {
		unixTime, err := strconv.Atoi(message.DateUnixtime)
		if err != nil {
			fmt.Printf("Error parsing unix time: %v\n", err)
			continue
		}

		user, ok := users[message.FromID]
		if !ok {
			user = &User{
				ID:           message.FromID,
				Name:         message.From,
				FirstSeen:    time.Unix(int64(unixTime), 0),
				CountMessage: 0,
			}
			users[message.FromID] = user
			newUsersCount++
		}

		dt := time.Unix(int64(unixTime), 0)
		if dt.Before(time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC)) || message.ReplyToMessageID != 0 {
			continue
		}

		text := ""
		for _, entity := range message.TextEntities {
			text += entity.Text
		}
		text = strings.ReplaceAll(text, "\n", " ")
		text = strings.TrimSpace(text)
		if text == "" {
			continue
		}

		if i%100 == 0 {
			fmt.Println(i, time.Now())
		}

		user.CountMessage++
		if user.CountMessage == 1 {
			user.FirstMessage = text
		}
	}

	fmt.Printf("New users count: %d\n", newUsersCount)

	sorted := make([]*User, 0, len(users))
	for _, user := range users {
		if user.FirstMessage != "" {
			sorted = append(sorted, user)
		}
	}
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].CountMessage > sorted[j].CountMessage
	})

	file, err := os.Create(*outputFile)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, user := range sorted {
		err := writer.Write([]string{
			// user.ID,
			// user.Name,
			// user.FirstSeen.Format("2006-01-02"),
			// strconv.Itoa(user.CountMessage),
			fmt.Sprintf("%s", user.FirstMessage),
		})
		if err != nil {
			fmt.Printf("Error writing to CSV: %v\n", err)
			os.Exit(1)
		}
	}

	fmt.Println("Analysis complete. Results written to", *outputFile)
}
